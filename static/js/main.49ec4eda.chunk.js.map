{"version":3,"sources":["model/updaters.ts","model/reducer.ts","solver/reducer.ts","solver/checkForInsolubility.ts","solver/cleanUpPossibles.ts","solver/datumSingleValue.ts","solver/groupMissingOneDatum.ts","solver/groupClosedSets.ts","solver/groupTuples.ts","solver/groupIntersections.ts","reducer.ts","model/Value.ts","ui/ColumnCell.tsx","ui/NumberCell.tsx","ui/GridCell.tsx","ui/RowCell.tsx","model/Datum.ts","model/Intersection.ts","model/Grid.ts","model/Group.ts","model/factory.ts","model/importers.ts","ui/Toolbar.tsx","ui/BoxCell.tsx","ui/Table.tsx","App.tsx","serviceWorker.ts","index.tsx"],"names":["byValue","a","b","removePossible","grid","id","value","datum","data","possible","includes","filter","p","insoluble","setActual","groups","solved","actual","datumGroups","clearActual","i","length","group","groupData","groupId","missing","j","otherId","other","duplicates","s","m","undefined","d","push","sort","SOLVERS","newGrid","groupIds","k","gridData","map","sets","set","join","values","split","v","ids","size","tuples","tmp","tuple","good","bad","count","intersections","datumIds","l","otherData","GRID_REDUCERS","state","action","type","addPossible","reducer","past","future","reset","ALL_VALUES","React","memo","className","rowSpan","key","NUMBERS","NumberCell","dispatch","classes","onLeftClick","e","onRightClick","stopPropagation","preventDefault","onClick","onContextMenu","ACTUAL","colSpan","Datum","this","Intersection","Grid","dataI","dataJ","Group","makeStandardGrid","datumId","rowId","row","columnId","column","blockId","block","Math","floor","importStandardGrid","content","Toolbar","canUndo","canRedo","useState","setContent","running","setRunning","percent","canSolve","noSolve","undo","useCallback","redo","step","clear","doImport","useEffect","interval","window","setInterval","clearInterval","disabled","onChange","target","INDICES","CLASSX","CLASSY","props","y","x","App","useReducer","Boolean","location","hostname","match","ReactDOM","render","StrictMode","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister","catch","error","console","message"],"mappings":"mYAKMA,EAA0C,SAACC,EAAGC,GAAJ,OAAUD,EAAIC,GAUvD,SAASC,EACZC,EACAC,EACAC,GAEA,IAAMC,EAAQH,EAAKI,KAAKH,GAChBI,EAAaF,EAAbE,SAER,IAAKA,EAASC,SAASJ,GACnB,OAAOF,EAGX,IAAMI,EAAI,YAAQJ,EAAKI,MASvB,OAPAA,EAAKH,GAAL,eACOE,EADP,CAEIE,SAAUA,EAASE,QAAO,SAAAC,GAAC,OAAIA,IAAMN,OAKlC,eAAKF,EAAZ,CAAkBI,OAAMK,WAAW,IA2ChC,SAASC,EACZV,EACAC,EACAC,GACK,IACCE,EAAyBJ,EAAzBI,KAAMO,EAAmBX,EAAnBW,OAAQC,EAAWZ,EAAXY,OAChBT,EAAQC,EAAKH,GAFb,EAG8CE,EAA1CU,EAHJ,EAGIA,OAAgBC,EAHpB,EAGYH,OAAqBN,EAHjC,EAGiCA,SAErC,GAAKQ,IAAWX,IAAWG,EAASC,SAASJ,GACzC,OAAOF,EACJ,GAAIa,EACP,OAAOH,EAAUK,EAAYf,EAAMC,GAAKA,EAAIC,GAGhDE,EAAI,YAAQA,GACZO,EAAM,YAAQA,GACdC,EAAM,sBAAQA,GAAR,CAAgBX,IACtBE,EAAK,eAAQA,EAAR,CAAeU,OAAQX,IAC5BE,EAAKH,GAAME,EAEX,IAAK,IAAIa,EAAI,EAAGA,EAAIL,EAAOM,OAAQD,IAAK,CACpC,IAAME,EAAQP,EAAOK,GACPG,EAAoCD,EAA1Cd,KAAqBgB,EAAqBF,EAAzBjB,GAAaoB,EAAYH,EAAZG,QAEtC,GAAKP,EAAYR,SAASc,GAA1B,CAIA,IARoC,eAQ3BE,GACL,IAAMC,EAAUJ,EAAUG,GAE1B,GAAIC,IAAYtB,EACZ,iBAGJ,IAAMuB,EAAQpB,EAAKmB,GACXV,EAAqBW,EAArBX,OAAQR,EAAamB,EAAbnB,SAEhB,GAAIQ,IAAWX,GASX,GARKC,EAAMsB,WAAWnB,SAASiB,KAC3BpB,EAAMsB,WAAN,sBAAwBtB,EAAMsB,YAA9B,CAA0CF,IAEV,IAA5BpB,EAAMsB,WAAWR,SACjBL,EAASA,EAAOL,QAAO,SAAAmB,GAAC,OAAIA,IAAMzB,QAIrCuB,EAAMC,WAAWnB,SAASL,GAAK,CAChC,IAAMwB,EAAU,sBAAQD,EAAMC,YAAd,CAA0BxB,IAE1CG,EAAKmB,GAAL,eAAqBC,EAArB,CAA4BC,eAEF,IAAtBA,EAAWR,SACXL,EAASA,EAAOL,QAAO,SAAAmB,GAAC,OAAIA,IAAMH,YAGnClB,EAASC,SAASJ,KACzBE,EAAKmB,GAAL,eACOC,EADP,CAEInB,SAAUA,EAASE,QAAO,SAAAC,GAAC,OAAIA,IAAMN,SA/BxCoB,EAAI,EAAGA,EAAIH,EAAUF,OAAQK,IAAK,EAAlCA,GAoCTX,EAAOK,GAAP,eAAiBE,EAAjB,CAAwBG,QAASA,EAAQd,QAAO,SAAAoB,GAAC,OAAIA,IAAMzB,QAG/D,OAAO,eAAKF,EAAZ,CAAkBI,OAAMO,SAAQC,SAAQH,WAAW,IAUhD,SAASM,EACZf,EACAC,GACK,IACCG,EAAyBJ,EAAzBI,KAAMO,EAAmBX,EAAnBW,OAAQC,EAAWZ,EAAXY,OAChBT,EAAQC,EAAKH,GACTY,EAAgCV,EAAhCU,OAAgBC,EAAgBX,EAAxBQ,OAEhB,IAAKE,EACD,OAAOb,EAGXI,EAAI,YAAQA,GACZO,EAAM,YAAQA,GACdC,EAASA,EAAOL,QAAO,SAAAmB,GAAC,OAAIA,IAAMzB,KAClCG,EAAKH,GAAL,eAAgBE,EAAhB,CAAuBU,YAAQe,EAAWH,WAAY,KAEtD,IAAK,IAAIL,EAAU,EAAGA,EAAUT,EAAOM,OAAQG,IAC3C,GAAKN,EAAYR,SAASc,GAA1B,CAOA,IAHA,IAAMF,EAAQP,EAAOS,GACPD,EAAuBD,EAA7Bd,KAAiBiB,EAAYH,EAAZG,QAEhBC,EAAI,EAAGA,EAAIH,EAAUF,OAAQK,IAAK,CACvC,IAAMC,EAAUJ,EAAUG,GAE1B,GAAIC,IAAYtB,EAAhB,CAIA,IAAMuB,EAAQpB,EAAKmB,GAEnB,GAAIC,EAAMX,SAAWA,GACbW,EAAMC,WAAWnB,SAASL,GAAK,CAC/B,IAAMwB,EAAaD,EAAMC,WAAWlB,QAAO,SAAAsB,GAAC,OAAIA,IAAM5B,KAEtDG,EAAKmB,GAAL,eAAqBC,EAArB,CAA4BC,eAEF,IAAtBA,EAAWR,QACXL,EAAOkB,KAAKP,KAO5BZ,EAAOS,GAAP,eACOF,EADP,CAEIG,QAAS,sBAAKA,GAAL,CAAcR,IAASkB,KAAKnC,KAI7C,OAAO,eAAKI,EAAZ,CAAkBI,OAAMO,SAAQC,SAAQH,WAAW,ICvMvD,ICCMuB,EAAyB,CCNM,SAAAhC,GAGjC,IAH0C,IAClCI,EAASJ,EAATI,KAECY,EAAI,EAAGA,EAAIZ,EAAKa,OAAQD,IAAK,CAAC,IAAD,EACOZ,EAAKY,GAAtCH,EAD0B,EAC1BA,OAAQY,EADkB,EAClBA,WAAYpB,EADM,EACNA,SAE5B,GACKoB,EAAWR,OAAS,GACG,IAApBZ,EAASY,QACTJ,IAAWR,EAASC,SAASO,GAEjC,OAAO,eAAKb,EAAZ,CAAkBS,WAAW,IAMrC,OAAOT,GChBsB,SAAAA,GAI7B,IAJsC,IAC9BI,EAAiBJ,EAAjBI,KAAMO,EAAWX,EAAXW,OACVsB,EAAUjC,EAELgB,EAAI,EAAGA,EAAIZ,EAAKa,OAAQD,IAG7B,IAHmC,IAAD,EACiBZ,EAAKY,GAAhDH,EAD0B,EAC1BA,OAAQZ,EADkB,EAClBA,GAAII,EADc,EACdA,SAAkB6B,EADJ,EACJvB,OAErBW,EAAI,EAAGA,EAAIjB,EAASY,OAAQK,IAAK,CACtC,IAAMpB,EAAQG,EAASiB,GAEvB,GAAIpB,IAAUW,EAEd,IAAK,IAAIsB,EAAI,EAAGA,EAAID,EAASjB,OAAQkB,IAAK,CAClBxB,EAAOuB,EAASC,IAA5Bd,QAEKf,SAASJ,KAClB+B,EAAUlC,EAAekC,EAAShC,EAAIC,KAMtD,OAAO+B,GCtBsB,SAAAjC,GAG7B,IAHsC,IAC9BI,EAASJ,EAATI,KAECH,EAAK,EAAGA,EAAKG,EAAKa,OAAQhB,IAAM,CAAC,IAAD,EACRG,EAAKH,GAA1BY,EAD6B,EAC7BA,OAAQR,EADqB,EACrBA,SAEhB,IAAKQ,GAA+B,IAApBR,EAASY,OACrB,OAAOP,EAAUV,EAAMC,EAAII,EAAS,IAI5C,OAAOL,GCX0B,SAAAA,GAGjC,IAH0C,IAC5BoC,EAAapC,EAAnBI,KAECH,EAAK,EAAGA,EAAKD,EAAKW,OAAOM,OAAQhB,IAItC,IAJ6C,IAAD,EACPD,EAAKW,OAAOV,GAAnCkB,EAD8B,EACpCf,KAAiBiB,EADmB,EACnBA,QACnBjB,EAAOe,EAAUkB,KAAI,SAAAR,GAAC,OAAIO,EAASP,MAAItB,QAAO,SAAAsB,GAAC,OAAKA,EAAEhB,UAFhB,WAInCG,GACL,IAAMd,EAAQmB,EAAQL,GAChBX,EAAWD,EAAKG,QAAO,SAAAsB,GAAC,OAAIA,EAAExB,SAASC,SAASJ,MAEtD,GAAwB,IAApBG,EAASY,OACT,MAAM,CAAN,EAAOP,EAAUV,EAAMK,EAAS,GAAGJ,GAAIC,KALtCc,EAAI,EAAGA,EAAIK,EAAQJ,OAAQD,IAAK,CAAC,IAAD,IAAhCA,GAAgC,kCAU7C,OAAOhB,GCfqB,SAAAA,GAI5B,IAJqC,IACvBoC,EAAqBpC,EAA3BI,KAAgBO,EAAWX,EAAXW,OACpBsB,EAAUjC,EAELoB,EAAU,EAAGA,EAAUT,EAAOM,OAAQG,IAAW,CAOtD,IANA,IAAMkB,EAA0C,GAE1ClC,EADsBO,EAAOS,GAA3BhB,KACeiC,KAAI,SAAAR,GAAC,OAAIO,EAASP,MAAItB,QAAO,SAAAsB,GAAC,OAAKA,EAAEhB,UAInDG,EAAI,EAAGA,EAAIZ,EAAKa,OAAQD,IAAK,CAAC,IAAD,EACTZ,EAAKY,GAAtBf,EAD0B,EAC1BA,GACFsC,EAF4B,EACtBlC,SACSmC,OAEjBF,EAAKC,GACLD,EAAKC,GAAKT,KAAK7B,GAEfqC,EAAKC,GAAO,CAAEtC,GAQtB,IAAK,IAAIsC,KAAOD,EAAM,CAClB,IAAMG,EAASF,EAAIG,MAAM,KAAKL,KAAI,SAAAM,GAAC,OAAKA,KAClCC,EAAMN,EAAKC,GAEjB,GAAIE,EAAOxB,SAAW2B,EAAI3B,OAAQ,CAI9B,IAAK,IAAID,EAAI,EAAGA,EAAIZ,EAAKa,OAAQD,IAAK,CAAC,IAAD,EACTZ,EAAKY,GAAtBf,EAD0B,EAC1BA,GAAII,EADsB,EACtBA,SAEZ,IAAKuC,EAAItC,SAASL,GACd,IAAK,IAAIqB,EAAI,EAAGA,EAAIjB,EAASY,OAAQK,IAAK,CACtC,IAAMpB,EAAQG,EAASiB,GAEnBmB,EAAOnC,SAASJ,KAChB+B,EAAUlC,EAAekC,EAAShC,EAAIC,KAMtD,GAAI+B,IAAYjC,EAAM,OAAOiC,OAC1B,GAAIQ,EAAOxB,OAAS2B,EAAI3B,OAE3B,OAAO,eAAKjB,EAAZ,CAAkBS,WAAW,KAKzC,OAAOT,GCvDiB,SAAAA,GAIxB,IAJiC,IACrBoC,EAAapC,EAAnBI,KACF6B,EAAUjC,EAELC,EAAK,EAAGA,EAAKD,EAAKW,OAAOM,OAAQhB,IAAM,CAAC,IAAD,EACPD,EAAKW,OAAOV,GAAnCkB,EAD8B,EACpCf,KAAiBiB,EADmB,EACnBA,QAGzB,KAAIA,EAAQJ,OAAS,GAKrB,IAHA,IAAMb,EAAOe,EAAUkB,KAAI,SAAAR,GAAC,OAAIO,EAASP,MAAItB,QAAO,SAAAsB,GAAC,OAAKA,EAAEhB,UAGnDgC,EAAO,EAAGA,EAAQxB,EAAQJ,OAAS,EAAI4B,IAAQ,CAIpD,IAHA,IAAIC,EAA8B,GAGzB9B,EAAI,EAAGA,EAAI6B,EAAM7B,IAAK,CAC3B,IAAI+B,EAAMD,EAEVA,EAAS,GAET,IAAK,IAAIxB,EAAI,EAAGA,EAAIyB,EAAI9B,OAAQK,IAG5B,IAFA,IAAM0B,EAAQD,EAAIzB,GAETa,EAAI,EAAGA,EAAId,EAAQJ,OAAQkB,IAAK,CACrC,IAAMjC,EAAQmB,EAAQc,GAEjBa,EAAM1C,SAASJ,IAChB4C,EAAOhB,KAAP,sBAAiBkB,GAAjB,CAAwB9C,MAOxC,IAvBoD,eAuB3Cc,GAOL,IANA,IAAMgC,EAAQF,EAAO9B,GACfiC,EAAqB,GACvBC,GAAM,EAID5B,EAAI,EAAGA,EAAIlB,EAAKa,OAAQK,IAAK,CAClC,IAAMnB,EAAQC,EAAKkB,GAEb6B,EADehD,EAAbE,SACeE,QAAO,SAAAC,GAAC,OAAIwC,EAAM1C,SAASE,MAAIS,OAElDkC,IAAUH,EAAM/B,OAChBgC,EAAKnB,KAAK3B,GACHgD,EAAQ,IACfD,GAAM,GAOd,IAAKA,GAAQD,EAAKhC,SAAW+B,EAAM/B,OAC/B,IAAK,IAAIK,EAAI,EAAGA,EAAI2B,EAAKhC,OAAQK,IAG7B,IAHmC,IAAD,EACT2B,EAAK3B,GAAtBrB,EAD0B,EAC1BA,GAAII,EADsB,EACtBA,SAEH8B,EAAI,EAAGA,EAAI9B,EAASY,OAAQkB,IAAK,CACtC,IAAMjC,EAAQG,EAAS8B,GAElBa,EAAM1C,SAASJ,KAChB+B,EAAUlC,EAAekC,EAAShC,EAAIC,IAMtD,GAAI+B,IAAYjC,EAAM,MAAM,CAAN,EAAOiC,IApCxBjB,EAAI,EAAGA,EAAI8B,EAAO7B,OAAQD,IAAK,CAAC,IAAD,IAA/BA,GAA+B,oCAyChD,OAAOhB,GC9EwB,SAAAA,GAK/B,IALwC,IAChCI,EAAgCJ,EAAhCI,KAAMgD,EAA0BpD,EAA1BoD,cAAezC,EAAWX,EAAXW,OACzBsB,EAAUjC,EAGLgB,EAAI,EAAGA,EAAIoC,EAAcnC,OAAQD,IAItC,IAJ4C,IAAD,EACEoC,EAAcpC,GAA7CqC,EAD6B,EACnCjD,KAAwB8B,EADW,EACnBvB,OAGfW,EAAI,EAAGA,EAAIY,EAASjB,OAAQK,IAIjC,IAJuC,IAAD,EACDX,EAAOuB,EAASZ,IAAvCH,EADwB,EAC9Bf,KAAiBiB,EADa,EACbA,QAGhBc,EAAI,EAAGA,EAAId,EAAQJ,OAAQkB,IAAK,CAKrC,IAJA,IAAMjC,EAAQmB,EAAQc,GAClBe,GAAM,EAGDI,EAAI,EAAGA,EAAInC,EAAUF,OAAQqC,IAClC,IAAKD,EAAS/C,SAASa,EAAUmC,IAAK,CAAC,IAAD,EACLlD,EAAKe,EAAUmC,IAApCzC,EAD0B,EAC1BA,OAAQR,EADkB,EAClBA,SAEhB,IAAKQ,GAAUR,EAASC,SAASJ,GAAQ,CACrCgD,GAAM,EACN,OAKZ,IAAIA,EAAJ,CAGA,IAAK,IAAII,EAAI,EAAGA,EAAIpB,EAASjB,OAAQqC,IACjC,GAAIA,IAAMhC,EAKV,IANsC,IAGxBiC,EAAc5C,EAAOuB,EAASoB,IAApClD,KAGCuB,EAAI,EAAGA,EAAI4B,EAAUtC,OAAQU,IAAK,CACvC,IAAM1B,EAAKsD,EAAU5B,GAErB,IAAK0B,EAAS/C,SAASL,GAAK,CAAC,IAAD,EACKG,EAAKH,GAA1BY,EADgB,EAChBA,OAAQR,EADQ,EACRA,UAEXQ,GAAUR,EAASC,SAASJ,KAC7B+B,EAAUlC,EAAekC,EAAShC,EAAIC,KAMtD,GAAI+B,IAAYjC,EAAM,OAAOiC,GAKzC,OAAOjC,IC3CLwD,EAAgB,CTXO,SAACC,EAAaC,GACvC,OAAQA,EAAOC,MACX,IAAK,iBACD,OAAO5D,EAAe0D,EAAOC,EAAOvD,MAAOuD,EAAOrD,UACtD,IAAK,cACD,OD8BL,SACHL,EACAC,EACAC,GAEA,IAAMC,EAAQH,EAAKI,KAAKH,GAChBI,EAAaF,EAAbE,SAER,GAAIA,EAASC,SAASJ,GAClB,OAAOF,EAGX,IAAMI,EAAI,YAAQJ,EAAKI,MASvB,OAPAA,EAAKH,GAAL,eACOE,EADP,CAEIE,SAAU,sBAAKA,GAAL,CAAeH,IAAQ6B,KAAKnC,KAKnC,eAAKI,EAAZ,CAAkBI,OAAMK,WAAW,ICnDpBmD,CAAYH,EAAOC,EAAOvD,MAAOuD,EAAOrD,UACnD,IAAK,YACD,OAAOK,EAAU+C,EAAOC,EAAOvD,MAAOuD,EAAO7C,QACjD,IAAK,cACD,OAAOE,EAAY0C,EAAOC,EAAOvD,OACrC,QACI,OAAOsD,ICOU,SAACA,EAAaC,GACvC,OAAQA,EAAOC,MACX,IAAK,QAAL,IACYvD,EAA4BqD,EAA5BrD,KAAMK,EAAsBgD,EAAtBhD,UAAWG,EAAW6C,EAAX7C,OAEzB,GAAIH,EACA,OAAOgD,EACJ,GAAI7C,EAAOK,SAAWb,EAAKa,OAC9B,OAAOwC,EAGX,IAAK,IAAIzC,EAAI,EAAGA,EAAIgB,EAAQf,OAAQD,IAAK,CACrC,IAAMhB,EAAOgC,EAAQhB,GAAGyC,GAExB,GAAIzD,IAASyD,EACT,OAAOzD,EAIf,OAAO,eAAKyD,EAAZ,CAAmBhD,WAAW,IAClC,QACI,OAAOgD,KQoCJI,EApDU,SAACJ,EAAcC,GACpC,OAAQA,EAAOC,MACX,IAAK,UACD,MAAO,CACH3D,KAAM0D,EAAO1D,KACb8D,KAAM,GACNC,OAAQ,GACRC,MAAOP,GAEf,IAAK,OACD,GAAIA,EAAMO,MACN,OAAOP,EAAMO,MACV,GAAIP,EAAMK,KAAK7C,OAAS,EAAG,CAAC,IAAD,cACJwC,EAAMK,MAEhC,MAAO,CACH9D,KAJ0B,KAK1B8D,KAL0B,WAM1BC,OAAO,CAAGN,EAAMzD,MAAV,mBAAmByD,EAAMM,UAGnC,OAAON,EAEf,IAAK,OACD,GAAIA,EAAMM,OAAO9C,OAAS,EAAG,CAAC,IAAD,cACGwC,EAAMM,QAA1B/D,EADiB,KACR+D,EADQ,WAGzB,MAAO,CACH/D,OACA8D,KAAK,CAAGL,EAAMzD,MAAV,mBAAmByD,EAAMK,OAC7BC,UAGJ,OAAON,EAEf,QACI,IAAK,IAAIzC,EAAI,EAAGA,EAAIwC,EAAcvC,OAAQD,IAAK,CAC3C,IAAMhB,EAAOwD,EAAcxC,GAAGyC,EAAMzD,KAAM0D,GAE1C,GAAI1D,IAASyD,EAAMzD,KACf,MAAO,CACHA,OACA8D,KAAK,CAAGL,EAAMzD,MAAV,mBAAmByD,EAAMK,OAC7BC,OAAQ,IAKpB,OAAON,IC7ENQ,EAA2B,CAAE,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GCgBnDC,G,MAAAA,IAAMC,MAbyB,SAAC,GAA4B,IAAjB9C,EAAgB,EAAzBH,MAASG,QACtD,OACI,wBAAI+C,UAAU,aAAaC,QAAS,GAC/BJ,EAAW5B,KAAI,SAAAnC,GAAK,OACjB,0BAAMoE,IAAKpE,EAAOkE,UAAW/C,EAAQf,SAASJ,QACpC0B,EAAY,oBACjB1B,WCTfqE,G,MAAU,CAAE,GACd,uBACA,yBACA,wBACA,0BACA,4BACA,2BACA,0BACA,4BACA,6BAqFWC,EAzE+B,SAAC,GAEvC,IADJvE,EACG,EADHA,GAAIY,EACD,EADCA,OAAQR,EACT,EADSA,SAAUoB,EACnB,EADmBA,WAAYgD,EAC/B,EAD+BA,SAAUvE,EACzC,EADyCA,MAExCwE,EAAO,iBAAaH,EAAQrE,IAC5ByE,EAAc,SAACC,KACfC,EAAe,SAACD,GAChBA,EAAEE,kBACFF,EAAEG,kBA0DN,OAvDIlE,IAAWX,GACXwE,GAAW,UAEPjD,GAAcA,EAAWR,OAAS,IAClCyD,GAAW,cAGXzE,GAAMwE,IACNI,EAAe,SAAAD,GACXA,EAAEG,iBAEFN,EAAS,CACLd,KAAM,cACNxD,MAAOF,OAIZY,EACP6D,GAAW,YACJrE,GAAYA,EAASC,SAASJ,IACrCwE,GAAW,YAEPzE,GAAMwE,IACNE,EAAc,WACVF,EAAS,CACLd,KAAM,iBACNxD,MAAOF,EACPI,SAAUH,KAIlB2E,EAAe,SAAAD,GACXA,EAAEG,iBAEFN,EAAS,CACLd,KAAM,YACNxD,MAAOF,EACPY,OAAQX,QAKpBwE,GAAW,cAEPzE,GAAMwE,IACNE,EAAc,WACVF,EAAS,CACLd,KAAM,cACNxD,MAAOF,EACPI,SAAUH,OAOtB,0BAAMkE,UAAWM,EAASM,QAASL,EAC3BM,cAAeJ,GAClB3E,ICxFPgF,G,MAAS,CAAE,GACb,uBACA,yBACA,wBACA,0BACA,4BACA,2BACA,0BACA,4BACA,6BAyBWhB,MAAMC,MAhBqB,SAAC,GAAoC,IAAlChE,EAAiC,EAAjCA,MAAOsE,EAA0B,EAA1BA,SAAUL,EAAgB,EAAhBA,UACtDM,EAAO,eAAWN,GAKtB,OAHIjE,EAAMU,SAAQ6D,GAAW,IAAMQ,EAAO/E,EAAMU,SAClB,IAA1BV,EAAME,SAASY,SAAcyD,GAAW,eAGxC,wBAAIN,UAAWM,GACVT,EAAW5B,KAAI,SAAAnC,GAAK,OACjB,kBAAC,EAAD,eAAYoE,IAAKpE,EAAOA,MAAOA,EAAOuE,SAAUA,GACxCtE,WCbT+D,G,MAAAA,IAAMC,MAbmB,SAAC,GAA4B,IAAjB9C,EAAgB,EAAzBH,MAASG,QAChD,OACI,wBAAI+C,UAAU,UAAUe,QAAS,GAC5BlB,EAAW5B,KAAI,SAAAnC,GAAK,OACjB,0BAAMoE,IAAKpE,EAAOkE,UAAW/C,EAAQf,SAASJ,QACpC0B,EAAY,iBACjB1B,W,OCNAkF,EAiBjB,WAAYnF,GAAc,yBAf1BA,QAeyB,OAbzBI,SAayB,YAbT4D,GAaS,KAXzBpD,YAWyB,OATzBF,OAAyB,GASA,KAPzBc,WAA6B,GAQzB4D,KAAKpF,GAAKA,GCrBGqF,EAYjB,WAAY3E,EAAwBP,GAAuB,yBAV3DO,YAU0D,OAR1DP,UAQ0D,EACtDiF,KAAK1E,OAASA,EACd0E,KAAKjF,KAAOA,GCbCmF,EAkBjB,WAAYnF,EAAoBO,GAAuB,yBAhBvDP,UAgBsD,OAdtDO,YAcsD,OAZtDyC,mBAYsD,OAVtDxC,OAAyB,GAU6B,KARtDH,WAAY,EAWR,IAFA,IAAM2C,EAAqC,GADO,WAGzCpC,GAGL,IAN8C,IAIhCwE,EAAU7E,EAAOK,GAAvBZ,KAECkB,EAAIN,EAAI,EAAGM,EAAIX,EAAOM,OAAQK,IAAK,CACxC,IAAMmE,EAAQ9E,EAAOW,GAAGlB,KAAKG,QAAO,SAAAsB,GAAC,OAAI2D,EAAMlF,SAASuB,MAEpD4D,EAAMxE,OAAS,GACfmC,EAActB,KAAK,IAAIwD,EAAa,CAAEtE,EAAGM,GAAKmE,MAPjDzE,EAAI,EAAGA,EAAIL,EAAOM,OAAQD,IAAM,EAAhCA,GAYTqE,KAAKjF,KAAOA,EACZiF,KAAK1E,OAASA,EACd0E,KAAKjC,cAAgBA,GCjCRsC,EAajB,WAAYzF,GAAc,yBAX1BA,QAWyB,OATzBG,KAAuB,GASE,KAPzBiB,QAOyB,YAPI4C,GAQzBoB,KAAKpF,GAAKA,GCdX,SAAS0F,IAIZ,IAHA,IAAIvF,EAAqB,GACrBO,EAAuB,GAElBiF,EAAU,EAAGA,EAAU,GAAIA,IAChCxF,EAAKwF,GAAW,IAAIR,EAAMQ,GAG9B,IAAK,IAAI5E,EAAI,EAAGA,EAAI,EAAGA,IAAK,CAIxB,IAHA,IAAM6E,EAAQ7E,EACR8E,EAAMnF,EAAOK,GAAK,IAAI0E,EAAMG,GAEzBD,EAAe,EAAJ5E,EAAQ4E,EAAqB,GAAT5E,EAAI,GAAS4E,IACjDxF,EAAKwF,GAASjF,OAAOmB,KAAK+D,GAC1BC,EAAI1F,KAAK0B,KAAK8D,GAMlB,IAHA,IAAMG,EAAW/E,EAAI,EACjBgF,EAASrF,EAAOoF,GAAY,IAAIL,EAAMK,GAEjCH,EAAU5E,EAAG4E,EAAU,GAAIA,GAAW,EAC3CxF,EAAKwF,GAASjF,OAAOmB,KAAKiE,GAC1BC,EAAO5F,KAAK0B,KAAK8D,GAMrB,IAHA,IAAMK,EAAUjF,EAAI,GAChBkF,EAAQvF,EAAOsF,GAAW,IAAIP,EAAMO,GAE/B3E,EAAI,EAAGA,EAAI,EAAGA,IAAK,CACxB,IAAMsE,EAAY5E,EAAI,EAAK,EACA,GAApBmF,KAAKC,MAAMpF,EAAI,GACfM,EAAI,EACgB,EAApB6E,KAAKC,MAAM9E,EAAI,GAEtBlB,EAAKwF,GAASjF,OAAOmB,KAAKmE,GAC1BC,EAAM9F,KAAK0B,KAAK8D,IAIxB,OAAO,IAAIL,EAAKnF,EAAMO,GC1CnB,IAAM0F,EAA+B,SAAAC,GAIxC,IAHA,IAAItG,EAAO2F,IACP1F,EAAK,EAEAe,EAAI,EAAGA,EAAIsF,EAAQrF,OAAQD,IAChC,OAAQsF,EAAQtF,IACZ,IAAK,IACDf,IACA,MACJ,IAAK,IACDD,EAAOU,EAAUV,EAAMC,IAAM,GAC7B,MACJ,IAAK,IACDD,EAAOU,EAAUV,EAAMC,IAAM,GAC7B,MACJ,IAAK,IACDD,EAAOU,EAAUV,EAAMC,IAAM,GAC7B,MACJ,IAAK,IACDD,EAAOU,EAAUV,EAAMC,IAAM,GAC7B,MACJ,IAAK,IACDD,EAAOU,EAAUV,EAAMC,IAAM,GAC7B,MACJ,IAAK,IACDD,EAAOU,EAAUV,EAAMC,IAAM,GAC7B,MACJ,IAAK,IACDD,EAAOU,EAAUV,EAAMC,IAAM,GAC7B,MACJ,IAAK,IACDD,EAAOU,EAAUV,EAAMC,IAAM,GAC7B,MACJ,IAAK,IACDD,EAAOU,EAAUV,EAAMC,IAAM,GAOzC,OAAOD,GCoBIuG,G,MArDyB,SAAC,GAGlC,IAAD,IAFFvG,KAAQI,EAEN,EAFMA,KAAMQ,EAEZ,EAFYA,OAAQH,EAEpB,EAFoBA,UACtB+F,EACE,EADFA,QAASC,EACP,EADOA,QAAShC,EAChB,EADgBA,SAChB,EAC8BiC,mBAAS,IADvC,mBACMJ,EADN,KACeK,EADf,OAE8BD,oBAAS,GAFvC,mBAEME,EAFN,KAEeC,EAFf,KAIIC,EAAUX,KAAKC,MAAaxF,EAAOK,OAASb,EAAKa,OAA5B,KACrB8F,GAAYtG,GAAcqG,EAAU,IACpCE,EAAUJ,IAAYG,EAEtBE,EAAOC,uBAAY,kBAAMzC,EAAS,CAAEd,KAAM,WAAW,CAAEc,IACvD0C,EAAOD,uBAAY,kBAAMzC,EAAS,CAAEd,KAAM,WAAW,CAAEc,IACvD2C,EAAOF,uBAAY,kBAAMzC,EAAS,CAAEd,KAAM,YAAY,CAAEc,IAExD4C,EAAQH,uBAAY,kBAAMzC,EAAS,CACrCd,KAAM,UACN3D,KAAM2F,QACN,CAAElB,IAEA6C,EAAWJ,uBAAY,kBAAMzC,EAAS,CACxCd,KAAM,UACN3D,KAAMqG,EAAmBC,OACzB,CAAEA,EAAS7B,IAcf,OAZA8C,qBAAU,WACN,GAAIX,EAAS,CACT,GAAIG,EAAU,CACV,IAAMS,EAAWC,OAAOC,YAAYN,EAAM,KAE1C,OAAO,WAAQK,OAAOE,cAAcH,IAEpCX,GAAW,MAGpB,CAAEE,EAAUH,EAASC,EAAYO,IAGhC,yBAAKhD,UAAU,WACX,0BAAMA,UAAU,UAAU0C,EAA1B,YACCrG,GAAa,0BAAM2D,UAAU,aAAhB,aACd,4BAAQY,QAASiC,EAAMW,UAAWpB,GAAlC,QACA,4BAAQxB,QAASmC,EAAMS,UAAWnB,GAAlC,QACA,4BAAQzB,QAASoC,EAAMQ,SAAUZ,GAAjC,QACA,4BAAQhC,QAAS,kBAAM6B,GAAW,IAAOe,SAAUZ,GAAnD,OACA,4BAAQhC,QAAS,kBAAM6B,GAAW,IAAQe,UAAWhB,GAArD,QACA,4BAAQ5B,QAASqC,EAAOO,SAAUhB,GAAlC,SACA,2BAAO1G,MAAOoG,EAASuB,SAAW,SAAAjD,GAAC,OAAI+B,EAAW/B,EAAEkD,OAAO5H,UAC3D,4BAAQ8E,QAASsC,EAAUM,SAAUhB,GAArC,aC1CG1C,G,YAAAA,IAAMC,MAVmB,SAAC,GAA4B,IAAjB9C,EAAgB,EAAzBH,MAASG,QAChD,OACI,wBAAI+C,UAAU,WACTH,EAAW5B,KAAI,SAAAnC,GAAK,OACjB,kBAAC,EAAD,CAAYoE,IAAKpE,EAAOA,MAAOA,EAAOG,SAAUgB,YCJ1D0G,EAAU,CAAE,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GAEpCC,EAAS,CACX,WACA,GACA,aACA,YACA,GACA,aACA,YACA,GACA,aAGEC,EAAS,CACX,UACA,GACA,cACA,WACA,GACA,cACA,WACA,GACA,cAyDW/D,MAAMC,MA/Ce,SAAC+D,GAAW,IACpClI,EAAmBkI,EAAnBlI,KAAMyE,EAAayD,EAAbzD,SAEd,OACI,2BAAOL,UAAU,SACb,+BACI,4BACI,wBAAIe,QAAS,GACT,kBAAC,EAAY+C,MAIzB,+BACKH,EAAQ1F,KAAI,SAAA8F,GAAC,OACV,wBAAI7D,IAAK6D,GACJJ,EAAQ1F,KAAI,SAAA+F,GAAC,OACV,kBAAC,EAAD,CAAU9D,IAAK8D,EACXhE,UAAS,UAAK6D,EAAOE,GAAZ,YAAkBH,EAAOI,IAClCjI,MAAOH,EAAKI,KAAU,EAAJ+H,EAASC,GAC3B3D,SAAUA,OAElB,kBAAC,EAAD,CAASvD,MAAOlB,EAAKW,OAAOwH,SAGpC,4BACKJ,EAAQ1F,KAAI,SAAA+F,GAAC,OACV,kBAAC,EAAD,CAAY9D,IAAK8D,EAAGlH,MAAOlB,EAAKW,OAAOyH,EAAI,QAE/C,kBAAC,EAAD,CAASlH,MAAOlB,EAAKW,OAAO,MAC5B,kBAAC,EAAD,CAASO,MAAOlB,EAAKW,OAAO,MAC5B,kBAAC,EAAD,CAASO,MAAOlB,EAAKW,OAAO,OAEhC,4BACI,kBAAC,EAAD,CAASO,MAAOlB,EAAKW,OAAO,MAC5B,kBAAC,EAAD,CAASO,MAAOlB,EAAKW,OAAO,MAC5B,kBAAC,EAAD,CAASO,MAAOlB,EAAKW,OAAO,OAEhC,4BACI,kBAAC,EAAD,CAASO,MAAOlB,EAAKW,OAAO,MAC5B,kBAAC,EAAD,CAASO,MAAOlB,EAAKW,OAAO,MAC5B,kBAAC,EAAD,CAASO,MAAOlB,EAAKW,OAAO,Y,MC9DjC0H,MAff,WAAgB,IAAD,EACyCC,qBAChDzE,OAASjC,GAAW,WAChB,MAAO,CAAE5B,KAAM2F,IAAoB7B,KAAM,GAAIC,OAAQ,OAHlD,0BACD/D,EADC,EACDA,KAAM8D,EADL,EACKA,KAAMC,EADX,EACWA,OAAQC,EADnB,EACmBA,MAASS,EAD5B,KAOX,OACI,yBAAKL,UAAU,OACX,kBAAC,EAAD,CAAOpE,KAAMA,EAAMwG,QAAU1C,EAAK7C,OAAS,KAAQ+C,EAC/CyC,QAAS1C,EAAO9C,OAAS,EAAGwD,SAAUA,MCJlC8D,QACW,cAA7Bd,OAAOe,SAASC,UAEe,UAA7BhB,OAAOe,SAASC,UAEhBhB,OAAOe,SAASC,SAASC,MACvB,2DCZNC,IAASC,OACP,kBAAC,IAAMC,WAAP,KACE,kBAAC,EAAD,OAEFC,SAASC,eAAe,SDiIpB,kBAAmBC,WACrBA,UAAUC,cAAcC,MACrBC,MAAK,SAAAC,GACJA,EAAaC,gBAEdC,OAAM,SAAAC,GACLC,QAAQD,MAAMA,EAAME,c","file":"static/js/main.49ec4eda.chunk.js","sourcesContent":["import { DatumId } from './Datum'\nimport Grid from './Grid'\nimport Value from './Value'\n\n/** A comparison function for values. */\nconst byValue: (a: Value, b: Value) => number = (a, b) => a - b\n\n/**\n * Remove a possible value from a datum.\n *\n * @param grid The current state of the grid.\n * @param id The ID of the datum to modify.\n * @param value The possible value to remove from the datum.\n * @return The new state of the grid, possibly unchanged.\n */\nexport function removePossible(\n    grid: Grid,\n    id: DatumId,\n    value: Value\n): Grid {\n    const datum = grid.data[id]\n    const { possible } = datum\n\n    if (!possible.includes(value)) {\n        return grid // Short-circuit invalid operations\n    }\n\n    const data = [ ...grid.data ]\n\n    data[id] = {\n        ...datum,\n        possible: possible.filter(p => p !== value)\n    }\n\n    // TODO what if a group has no datum with actual/possible?\n\n    return { ...grid, data, insoluble: false }\n}\n\n/**\n * Add a possible value to a datum.\n *\n * @param grid The current state of the grid.\n * @param id The ID of the datum to modify.\n * @param value The possible value to add to the datum.\n * @return The new state of the grid, possibly unchanged.\n */\nexport function addPossible(\n    grid: Grid,\n    id: DatumId,\n    value: Value\n): Grid {\n    const datum = grid.data[id]\n    const { possible } = datum\n\n    if (possible.includes(value)) {\n        return grid // Short-circuit invalid operations\n    }\n\n    const data = [ ...grid.data ]\n\n    data[id] = {\n        ...datum,\n        possible: [ ...possible, value ].sort(byValue)\n    }\n\n    // TODO what if possible has an actual in a group?\n\n    return { ...grid, data, insoluble: false }\n}\n\n/**\n * Set the actual value of a datum.\n *\n * @param grid The current state of the grid.\n * @param id The ID of the datum to modify.\n * @param value The actual value for the datum.\n * @return The new state of the grid, possibly unchanged.\n */\nexport function setActual(\n    grid: Grid,\n    id: DatumId,\n    value: Value\n): Grid {\n    let { data, groups, solved } = grid\n    let datum = data[id]\n    const { actual, groups: datumGroups, possible } = datum\n\n    if ((actual === value) || !possible.includes(value)) {\n        return grid // Short-circuit invalid operations\n    } else if (actual) {\n        return setActual(clearActual(grid, id), id, value)\n    }\n\n    data = [ ...data ]\n    groups = [ ...groups ]\n    solved = [ ...solved, id ]\n    datum = { ...datum, actual: value }\n    data[id] = datum\n\n    for (let i = 0; i < groups.length; i++) {\n        const group = groups[i]\n        const { data: groupData, id: groupId, missing } = group\n\n        if (!datumGroups.includes(groupId)) {\n            continue\n        }\n\n        for (let j = 0; j < groupData.length; j++) {\n            const otherId = groupData[j]\n\n            if (otherId === id) {\n                continue\n            }\n\n            const other = data[otherId]\n            const { actual, possible } = other\n\n            if (actual === value) {\n                if (!datum.duplicates.includes(otherId)) {\n                    datum.duplicates = [ ...datum.duplicates, otherId ]\n\n                    if (datum.duplicates.length === 1) {\n                        solved = solved.filter(s => s !== id)\n                    }\n                }\n\n                if (!other.duplicates.includes(id)) {\n                    const duplicates = [ ...other.duplicates, id ]\n\n                    data[otherId] = { ...other, duplicates }\n\n                    if (duplicates.length === 1) {\n                        solved = solved.filter(s => s !== otherId)\n                    }\n                }\n            } else if (possible.includes(value)) {\n                data[otherId] = {\n                    ...other,\n                    possible: possible.filter(p => p !== value)\n                }\n            }\n        }\n\n        groups[i] = { ...group, missing: missing.filter(m => m !== value) }\n    }\n\n    return { ...grid, data, groups, solved, insoluble: false }\n}\n\n/**\n * Clear the actual value of a datum.\n *\n * @param grid The current state of the grid.\n * @param id The ID of the datum to modify.\n * @return The new state of the grid, possibly unchanged.\n */\nexport function clearActual(\n    grid: Grid,\n    id: DatumId\n): Grid {\n    let { data, groups, solved } = grid\n    let datum = data[id]\n    const { actual, groups: datumGroups } = datum\n\n    if (!actual) {\n        return grid // Short-circuit invalid operations\n    }\n\n    data = [ ...data ]\n    groups = [ ...groups ]\n    solved = solved.filter(s => s !== id)\n    data[id] = { ...datum, actual: undefined, duplicates: [] }\n\n    for (let groupId = 0; groupId < groups.length; groupId++) {\n        if (!datumGroups.includes(groupId)) {\n            continue\n        }\n\n        const group = groups[groupId]\n        const { data: groupData, missing } = group\n\n        for (let j = 0; j < groupData.length; j++) {\n            const otherId = groupData[j]\n\n            if (otherId === id) {\n                continue\n            }\n\n            const other = data[otherId]\n\n            if (other.actual === actual) {\n                if (other.duplicates.includes(id)) {\n                    const duplicates = other.duplicates.filter(d => d !== id)\n\n                    data[otherId] = { ...other, duplicates }\n\n                    if (duplicates.length === 0) {\n                        solved.push(otherId)\n                    }\n                }\n            }\n        }\n\n        // TODO may not be correct if there are duplicates!\n        groups[groupId] = {\n            ...group,\n            missing: [ ...missing, actual ].sort(byValue)\n        }\n    }\n\n    return { ...grid, data, groups, solved, insoluble: false }\n}\n","import { AnyAction } from '../actions'\nimport Grid from './Grid'\nimport { GridReducer } from '../reducer'\nimport { addPossible, clearActual, removePossible, setActual } from './updaters'\n\n/**\n * A reducer for the grid.\n *\n * @param state The previous state.\n * @param action The action to undertake.\n * @return The new state, possibly unchanged.\n */\nconst reducer: GridReducer = (state: Grid, action: AnyAction) => {\n    switch (action.type) {\n        case 'RemovePossible':\n            return removePossible(state, action.datum, action.possible)\n        case 'AddPossible':\n            return addPossible(state, action.datum, action.possible)\n        case 'SetActual':\n            return setActual(state, action.datum, action.actual)\n        case 'ClearActual':\n            return clearActual(state, action.datum)\n        default:\n            return state\n    }\n}\n\nexport default reducer\n","import { AnyAction } from '../actions'\nimport Grid from '../model/Grid'\nimport { GridReducer } from '../reducer'\nimport Solver from './Solver'\nimport checkForInsolubility from './checkForInsolubility'\nimport cleanUpPossibles from './cleanUpPossibles'\nimport datumSingleValue from './datumSingleValue'\nimport groupMissingOneDatum from './groupMissingOneDatum'\nimport groupClosedSets from './groupClosedSets'\nimport groupTuples from './groupTuples'\nimport groupIntersections from './groupIntersections'\n\n/** The available solver methods, in order of priority. */\nconst SOLVERS: Array<Solver> = [\n    checkForInsolubility,\n    cleanUpPossibles,\n    datumSingleValue,\n    groupMissingOneDatum,\n    groupClosedSets,\n    groupTuples,\n    groupIntersections,\n]\n\n/**\n * A reducer for the grid.\n *\n * @param state The current state of the grid.\n * @param action The action to undertake.\n * @return The new state of the grid, possibly unchanged.\n */\nconst reducer: GridReducer = (state: Grid, action: AnyAction) => {\n    switch (action.type) {\n        case 'Solve':\n            const { data, insoluble, solved } = state\n\n            if (insoluble) {\n                return state // No changes since last failed attempt to solve\n            } else if (solved.length === data.length) {\n                return state // Already solved!\n            }\n\n            for (let i = 0; i < SOLVERS.length; i++) {\n                const grid = SOLVERS[i](state)\n\n                if (grid !== state) {\n                    return grid\n                }\n            }\n\n            return { ...state, insoluble: true }\n        default:\n            return state\n    }\n}\n\nexport default reducer\n","import Solver from './Solver'\n\n/**\n * Perform basic checks for insolubility.\n *\n * @param grid The initial state of the grid.\n */\nconst checkForInsolubility: Solver = grid => {\n    const { data } = grid\n\n    for (let i = 0; i < data.length; i++) {\n        const { actual, duplicates, possible } = data[i]\n\n        if (\n            (duplicates.length > 0)\n            || (possible.length === 0)\n            || (actual && !possible.includes(actual))\n        ) {\n            return { ...grid, insoluble: true }\n        }\n    }\n\n    // TODO check for groups with no possibles for a missing number\n\n    return grid\n}\n\nexport default checkForInsolubility\n","import Solver from './Solver'\nimport { removePossible } from '../model/updaters'\n\n/**\n * Clean up any possible values which are not, in fact, possible.\n *\n * @param grid The initial state of the grid.\n */\nconst cleanUpPossibles: Solver = grid => {\n    const { data, groups } = grid\n    let newGrid = grid\n\n    for (let i = 0; i < data.length; i++) {\n        const { actual, id, possible, groups: groupIds } = data[i]\n\n        for (let j = 0; j < possible.length; j++) {\n            const value = possible[j]\n\n            if (value === actual) continue\n\n            for (let k = 0; k < groupIds.length; k++) {\n                const { missing } = groups[groupIds[k]]\n\n                if (!missing.includes(value)) {\n                    newGrid = removePossible(newGrid, id, value)\n                }\n            }\n        }\n    }\n\n    return newGrid\n}\n\nexport default cleanUpPossibles\n","import Solver from './Solver'\nimport { setActual } from '../model/updaters'\n\n/**\n * Look for a datum which only has one possible value.\n *\n * @param grid The initial state of the grid.\n */\nconst datumSingleValue: Solver = grid => {\n    const { data } = grid\n\n    for (let id = 0; id < data.length; id++) {\n        const { actual, possible } = data[id]\n\n        if (!actual && (possible.length === 1)) {\n            return setActual(grid, id, possible[0])\n        }\n    }\n\n    return grid\n}\n\nexport default datumSingleValue\n","import Solver from './Solver'\nimport { setActual } from '../model/updaters'\n\n/**\n * Look for a missing group value which is only possible in one datum.\n *\n * @param grid The initial state of the grid.\n */\nconst groupMissingOneDatum: Solver = grid => {\n    const { data: gridData } = grid\n\n    for (let id = 0; id < grid.groups.length; id++) {\n        const { data: groupData, missing } = grid.groups[id]\n        const data = groupData.map(d => gridData[d]).filter(d => !d.actual)\n\n        for (let i = 0; i < missing.length; i++) {\n            const value = missing[i]\n            const possible = data.filter(d => d.possible.includes(value))\n\n            if (possible.length === 1) {\n                return setActual(grid, possible[0].id, value)\n            }\n        }\n    }\n\n    return grid\n}\n\nexport default groupMissingOneDatum\n","import Solver from './Solver'\nimport { DatumId } from '../model/Datum'\nimport { removePossible } from '../model/updaters'\n\n/**\n * Find closed sets (n data each containing only the same n values) and remove\n * remove those values from all other data.\n *\n * @param grid The initial state of the grid.\n */\nconst groupClosedSets: Solver = grid => {\n    const { data: gridData, groups } = grid\n    let newGrid = grid\n\n    for (let groupId = 0; groupId < groups.length; groupId++) {\n        const sets: { [key: string]: Array<DatumId> } = {}\n        const { data: groupData } = groups[groupId]\n        const data = groupData.map(d => gridData[d]).filter(d => !d.actual)\n\n        // Create a map of sets to data\n\n        for (let i = 0; i < data.length; i++) {\n            const { id, possible } = data[i]\n            const set = possible.join()\n\n            if (sets[set]) {\n                sets[set].push(id)\n            } else {\n                sets[set] = [ id ]\n            }\n        }\n\n        // TODO: to be correct, we should actually include subsets,\n        // e.g. 1,2,3 should also include 1,2 1,3 & 2,3\n        // Bonus points: go looking for supersets\n\n        for (let set in sets) {\n            const values = set.split(',').map(v => +v)\n            const ids = sets[set]\n\n            if (values.length === ids.length) {\n                // This is a closed set - these values are no longer possible\n                // in any of the other data in the group\n\n                for (let i = 0; i < data.length; i++) {\n                    const { id, possible } = data[i]\n\n                    if (!ids.includes(id)) {\n                        for (let j = 0; j < possible.length; j++) {\n                            const value = possible[j]\n\n                            if (values.includes(value)) {\n                                newGrid = removePossible(newGrid, id, value)\n                            }\n                        }\n                    }\n                }\n\n                if (newGrid !== grid) return newGrid\n            } else if (values.length < ids.length) {\n                // e.g Three cells in a group with possible of only 1,2\n                return { ...grid, insoluble: true }\n            }\n        }\n    }\n\n    return grid\n}\n\nexport default groupClosedSets\n","import Solver from './Solver'\nimport Datum from '../model/Datum'\nimport { removePossible } from '../model/updaters'\nimport Value from '../model/Value'\n\n/**\n * Find closed sets (n data each containing only the same n values) and remove\n * remove those values from all other data.\n *\n * @param grid The initial state of the grid.\n */\nconst groupTuples: Solver = grid => {\n    let { data: gridData } = grid\n    let newGrid = grid\n\n    for (let id = 0; id < grid.groups.length; id++) {\n        const { data: groupData, missing } = grid.groups[id]\n\n        // We only use tuples of size 2 to n-3, so need at least 5 values TODO why?\n        if (missing.length < 5) continue\n\n        const data = groupData.map(d => gridData[d]).filter(d => !d.actual)\n\n        // Iterate over size of tuple, starting small\n        for (let size = 2; size < (missing.length - 3); size++) {\n            let tuples: Array<Array<Value>> = []\n\n            // Create all the tuples of the given size\n            for (let i = 0; i < size; i++) {\n                let tmp = tuples\n\n                tuples = []\n\n                for (let j = 0; j < tmp.length; j++) {\n                    const tuple = tmp[j]\n\n                    for (let k = 0; k < missing.length; k++) {\n                        const value = missing[k]\n\n                        if (!tuple.includes(value)) {\n                            tuples.push([ ...tuple, value ])\n                        }\n                    }\n                }\n            }\n\n            // Check each tuple in turn\n            for (let i = 0; i < tuples.length; i++) {\n                const tuple = tuples[i]\n                const good: Array<Datum> = []\n                let bad = false\n\n                // Check cells to see if they contain the tuple, or if they\n                // contain a sub-set of the tuple (which is bad)\n                for (let j = 0; j < data.length; j++) {\n                    const datum = data[j]\n                    const { possible } = datum\n                    const count = possible.filter(p => tuple.includes(p)).length\n\n                    if (count === tuple.length) {\n                        good.push(datum)\n                    } else if (count > 0) {\n                        bad = true\n                    }\n                }\n\n                // If the number of cells containing the tuple is the same as\n                // the number of values in the tuple, remove all other values\n                // from those cells\n                if (!bad && (good.length === tuple.length)) {\n                    for (let j = 0; j < good.length; j++) {\n                        const { id, possible } = good[j]\n\n                        for (let k = 0; k < possible.length; k++) {\n                            const value = possible[k]\n\n                            if (!tuple.includes(value)) {\n                                newGrid = removePossible(newGrid, id, value)\n                            }\n                        }\n                    }\n                }\n\n                if (newGrid !== grid) return newGrid\n            }\n        }\n    }\n\n    return grid\n}\n\nexport default groupTuples\n","import Solver from './Solver'\nimport { removePossible } from '../model/updaters'\n\n/**\n * Find values which, according to one group, can only appear in the\n * intersection between two or more groups, and remove them from the\n * non-intersecting cells of the other group(s) in the intersection\n *\n * @param grid The initial state of the grid.\n */\nconst groupIntersections: Solver = grid => {\n    const { data, intersections, groups } = grid\n    let newGrid = grid\n\n    // For each intersection\n    for (let i = 0; i < intersections.length; i++) {\n        const { data: datumIds, groups: groupIds } = intersections[i]\n\n        // For each group in the intersection\n        for (let j = 0; j < groupIds.length; j++) {\n            const { data: groupData, missing } = groups[groupIds[j]]\n\n            // For each missing value in the group\n            for (let k = 0; k < missing.length; k++) {\n                const value = missing[k]\n                let bad = false\n\n                // Check that the missing value only appears in the intersection\n                for (let l = 0; l < groupData.length; l++) {\n                    if (!datumIds.includes(groupData[l])) {\n                        const { actual, possible } = data[groupData[l]]\n\n                        if (!actual && possible.includes(value)) {\n                            bad = true\n                            break\n                        }\n                    }\n                }\n\n                if (bad) continue\n\n                // For every other group in the intersection\n                for (let l = 0; l < groupIds.length; l++) {\n                    if (l === j) continue\n\n                    const { data: otherData } = groups[groupIds[l]]\n\n                    // For every cell that's not in the intersection\n                    for (let m = 0; m < otherData.length; m++) {\n                        const id = otherData[m]\n\n                        if (!datumIds.includes(id)) {\n                            const { actual, possible } = data[id]\n\n                            if (!actual && possible.includes(value)) {\n                                newGrid = removePossible(newGrid, id, value)\n                            }\n                        }\n                    }\n                }\n\n                if (newGrid !== grid) return newGrid\n            }\n        }\n    }\n\n    return grid\n}\n\nexport default groupIntersections\n","import { AnyAction } from './actions'\nimport Grid from './model/Grid'\nimport State from './State'\nimport modelReducer from './model/reducer'\nimport solverReducer from './solver/reducer'\n\n/** Defines a reducer. */\nexport type Reducer = (\n    /** The previous state. */\n    state: State,\n    /** The action to undertake. */\n    action: AnyAction\n) => State\n\n/** Defines a grid reducer. */\nexport type GridReducer = (\n    /** The previous state. */\n    state: Grid,\n    /** The action to undertake. */\n    action: AnyAction\n) => Grid\n\n/** The available reducers. */\nconst GRID_REDUCERS = [\n    modelReducer,\n    solverReducer,\n]\n\n/**\n * The application's reducer.\n *\n * @param state The previous state.\n * @param action The action to undertake.\n * @return The new state, possibly unchanged.\n */\nconst reducer: Reducer = (state: State, action: AnyAction) => {\n    switch (action.type) {\n        case 'SetGrid':\n            return {\n                grid: action.grid,\n                past: [],\n                future: [],\n                reset: state,\n            }\n        case 'Undo':\n            if (state.reset) {\n                return state.reset\n            } else if (state.past.length > 0) {\n                const [ grid, ...past ] = state.past\n\n                return {\n                    grid,\n                    past,\n                    future: [ state.grid, ...state.future ],\n                }\n            } else {\n                return state\n            }\n        case 'Redo':\n            if (state.future.length > 0) {\n                const [ grid, ...future ] = state.future\n\n                return {\n                    grid,\n                    past: [ state.grid, ...state.past ],\n                    future,\n                }\n            } else {\n                return state\n            }\n        default:\n            for (let i = 0; i < GRID_REDUCERS.length; i++) {\n                const grid = GRID_REDUCERS[i](state.grid, action)\n\n                if (grid !== state.grid) {\n                    return {\n                        grid,\n                        past: [ state.grid, ...state.past ],\n                        future: [],\n                    }\n                }\n            }\n\n            return state\n    }\n}\n\nexport default reducer\n","/** A possible value in a Sudoku grid. */\ntype Value = 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9\n\nexport default Value\n\n/** All the possible values in a Sudoku grid. */\nexport const ALL_VALUES: Array<Value> = [ 1, 2, 3, 4, 5, 6, 7, 8, 9 ]\n","import React from 'react'\nimport Group from '../model/Group'\nimport { ALL_VALUES } from '../model/Value'\nimport './ColumnCell.scss'\n\ntype ColumnCellProps = {\n    group: Group\n}\n\nconst ColumnCell: React.FC<ColumnCellProps> = ({ group: { missing } }) => {\n    return (\n        <td className=\"ColumnCell\" rowSpan={3}>\n            {ALL_VALUES.map(value =>\n                <span key={value} className={missing.includes(value)\n                        ? undefined : 'ColumnCellHidden'}>\n                    {value}\n                </span>\n            )}\n        </td>\n    )\n}\n\nexport default React.memo(ColumnCell)\n","import React from 'react'\nimport { DatumId } from '../model/Datum'\nimport { ModelAction } from '../model/actions'\nimport Value from '../model/Value'\nimport './NumberCell.scss'\n\nconst NUMBERS = [ '',\n    'NumberTop NumberLeft',\n    'NumberTop NumberCenter',\n    'NumberTop NumberRight',\n    'NumberMiddle NumberLeft',\n    'NumberMiddle NumberCenter',\n    'NumberMiddle NumberRight',\n    'NumberBottom NumberLeft',\n    'NumberBottom NumberCenter',\n    'NumberBottom NumberRight',\n]\n\ntype NumberCellProps = {\n    value: Value\n    possible: Array<Value>\n    id?: DatumId\n    actual?: Value\n    duplicates?: Array<DatumId>\n    dispatch?: React.Dispatch<ModelAction>\n}\n\nconst NumberCell: React.FC<NumberCellProps> = ({\n    id, actual, possible, duplicates, dispatch, value\n }) => {\n    let classes = `Number ${NUMBERS[value]}`\n    let onLeftClick = (e: React.MouseEvent) => {}\n    let onRightClick = (e: React.MouseEvent) => {\n        e.stopPropagation()\n        e.preventDefault()\n    }\n\n    if (actual === value) {\n        classes += ' Actual'\n\n        if (duplicates && duplicates.length > 0) {\n            classes += ' Duplicate'\n        }\n\n        if (id && dispatch) {\n            onRightClick = e => {\n                e.preventDefault()\n\n                dispatch({\n                    type: 'ClearActual',\n                    datum: id\n                })\n            }\n        }\n    } else if (actual) {\n        classes += ' Unactual'\n    } else if (possible && possible.includes(value)) {\n        classes += ' Possible'\n\n        if (id && dispatch) {\n            onLeftClick = () => {\n                dispatch({\n                    type: 'RemovePossible',\n                    datum: id,\n                    possible: value\n                })\n            }\n\n            onRightClick = e => {\n                e.preventDefault()\n\n                dispatch({\n                    type: 'SetActual',\n                    datum: id,\n                    actual: value\n                })\n            }\n        }\n    } else {\n        classes += ' Impossible'\n\n        if (id && dispatch) {\n            onLeftClick = () => {\n                dispatch({\n                    type: 'AddPossible',\n                    datum: id,\n                    possible: value\n                })\n            }\n        }\n    }\n\n    return (\n        <span className={classes} onClick={onLeftClick}\n                onContextMenu={onRightClick}>\n            {value}\n        </span>\n    )\n}\n\nexport default NumberCell\n","import React from 'react'\nimport Datum from '../model/Datum'\nimport { ModelAction } from '../model/actions'\nimport NumberCell from './NumberCell'\nimport { ALL_VALUES } from '../model/Value'\nimport './GridCell.scss'\n\nconst ACTUAL = [ '',\n    'ActualTop ActualLeft',\n    'ActualTop ActualCenter',\n    'ActualTop ActualRight',\n    'ActualMiddle ActualLeft',\n    'ActualMiddle ActualCenter',\n    'ActualMiddle ActualRight',\n    'ActualBottom ActualLeft',\n    'ActualBottom ActualCenter',\n    'ActualBottom ActualRight',\n]\n\ntype GridCellProps = {\n    datum: Datum\n    dispatch: React.Dispatch<ModelAction>\n    className?: string\n}\n\nconst GridCell: React.FC<GridCellProps> = ({ datum, dispatch, className }) => {\n    let classes = `Cell ${className}`\n\n    if (datum.actual) classes += ' ' + ACTUAL[datum.actual]\n    if (datum.possible.length === 0) classes += ' Impossible'\n\n    return (\n        <td className={classes}>\n            {ALL_VALUES.map(value =>\n                <NumberCell key={value} value={value} dispatch={dispatch}\n                    {...datum}/>\n            )}\n        </td>\n    )\n}\n\nexport default React.memo(GridCell)\n","import React from 'react'\nimport Group from '../model/Group'\nimport { ALL_VALUES } from '../model/Value'\nimport './RowCell.scss'\n\ntype RowCellProps = {\n    group: Group\n}\n\nconst RowCell: React.FC<RowCellProps> = ({ group: { missing } }) => {\n    return (\n        <td className=\"RowCell\" colSpan={3}>\n            {ALL_VALUES.map(value =>\n                <span key={value} className={missing.includes(value)\n                        ? undefined : 'RowCellHidden'}>\n                    {value}\n                </span>\n            )}\n        </td>\n    )\n}\n\nexport default React.memo(RowCell)\n","import { GroupId } from './Group'\nimport Value, { ALL_VALUES } from './Value'\n\n/** A unique identifier for a datum. Must be a non-negative integer. */\nexport type DatumId = number\n\n/**\n * A single datum within a Sudoku grid.\n */\nexport default class Datum {\n    /** The unique ID of this datum. */\n    id: DatumId\n    /** The possible numbers, empty if none. */\n    possible = [ ...ALL_VALUES ]\n    /** The actual selected number, or null. */\n    actual?: Value\n    /** Ids of the groups of which this datum is a member. */\n    groups: Array<GroupId> = []\n    /** Ids of datums which duplicate this actual datum. */\n    duplicates: Array<DatumId> = []\n\n    /**\n     * Create a new datum.\n     *\n     * @param id The datum's unique ID.\n     */\n    constructor(id: DatumId) {\n        this.id = id\n    }\n}\n","import { DatumId } from './Datum'\nimport { GroupId } from './Group'\n\n/**\n * Represents the intersection between two or more groups.\n */\nexport default class Intersection {\n    /** The IDs of the groups in the intersection. */\n    groups: Array<GroupId>\n    /** The IDs of the data in the intersection. */\n    data: Array<DatumId>\n\n    /**\n     * Create a new intersection.\n     *\n     * @param groups The IDs of the groups in the intersection.\n     * @param data The IDs of the data in the intersection.\n     */\n    constructor(groups: Array<GroupId>, data: Array<DatumId>) {\n        this.groups = groups\n        this.data = data\n    }\n}\n","import Datum, { DatumId } from './Datum'\nimport Group from './Group'\nimport Intersection from './Intersection'\n\n/**\n * A Sudoku grid.\n */\nexport default class Grid {\n    /** The grid data. */\n    data: Array<Datum>\n    /** The groups in the grid. */\n    groups: Array<Group>\n    /** The groups in the grid. */\n    intersections: Array<Intersection>\n    /** Ids of the data which have been solved. */\n    solved: Array<DatumId> = []\n    /** True iff the solver has flagged the grid as insoluble. */\n    insoluble = false\n\n    /**\n     * Create a new group.\n     *\n     * @param data The grid data.\n     * @param groups The groups in the grid.\n     */\n    constructor(data: Array<Datum>, groups: Array<Group>) {\n        const intersections: Array<Intersection> = []\n\n        for (let i = 0; i < groups.length; i++) {\n            const { data: dataI } = groups[i]\n\n            for (let j = i + 1; j < groups.length; j++) {\n                const dataJ = groups[j].data.filter(d => dataI.includes(d))\n\n                if (dataJ.length > 1) {\n                    intersections.push(new Intersection([ i, j ], dataJ))\n                }\n            }\n        }\n\n        this.data = data\n        this.groups = groups\n        this.intersections = intersections\n    }\n}\n","import { DatumId } from './Datum'\nimport Value, { ALL_VALUES } from './Value'\n\n/** A unique identifier for a group. Must be a non-negative integer. */\nexport type GroupId = number\n\n/**\n * A group of data sharing a constraint.\n */\nexport default class Group {\n    /** The unique ID of this group. */\n    id: GroupId\n    /** The IDs of the data which comprise this group. */\n    data: Array<DatumId> = []\n    /** The numbers which are missing from this group. */\n    missing: Array<Value> = [ ...ALL_VALUES ]\n\n    /**\n     * Create a new group.\n     *\n     * @param id The group's unique ID.\n     */\n    constructor(id: GroupId) {\n        this.id = id\n    }\n}\n","import Datum from './Datum'\nimport Grid from './Grid'\nimport Group from './Group'\n\n/**\n * Create a standard Sudoku grid.\n *\n * @returns The grid.\n */\nexport function makeStandardGrid(): Grid {\n    let data: Array<Datum> = []\n    let groups: Array<Group> = []\n\n    for (let datumId = 0; datumId < 81; datumId++) {\n        data[datumId] = new Datum(datumId)\n    }\n\n    for (let i = 0; i < 9; i++) {\n        const rowId = i\n        const row = groups[i] = new Group(rowId)\n\n        for (let datumId = (i * 9); datumId < ((i + 1) * 9); datumId++) {\n            data[datumId].groups.push(rowId)\n            row.data.push(datumId)\n        }\n\n        const columnId = i + 9\n        let column = groups[columnId] = new Group(columnId)\n\n        for (let datumId = i; datumId < 81; datumId += 9) {\n            data[datumId].groups.push(columnId)\n            column.data.push(datumId)\n        }\n\n        const blockId = i + 18\n        let block = groups[blockId] = new Group(blockId)\n\n        for (let j = 0; j < 9; j++) {\n            const datumId = ((i % 3) * 3)\n                + (Math.floor(i / 3) * 27)\n                + (j % 3)\n                + (Math.floor(j / 3) * 9)\n\n            data[datumId].groups.push(blockId)\n            block.data.push(datumId)\n        }\n    }\n\n    return new Grid(data, groups)\n}\n","import Grid from './Grid'\nimport { makeStandardGrid } from './factory'\nimport { setActual } from './updaters'\n\ntype Importer = (content: string) => Grid\n\nexport const importStandardGrid: Importer = content => {\n    let grid = makeStandardGrid()\n    let id = 0\n\n    for (let i = 0; i < content.length; i++) {\n        switch (content[i]) {\n            case '.':\n                id++\n                break\n            case '1':\n                grid = setActual(grid, id++, 1)\n                break\n            case '2':\n                grid = setActual(grid, id++, 2)\n                break\n            case '3':\n                grid = setActual(grid, id++, 3)\n                break\n            case '4':\n                grid = setActual(grid, id++, 4)\n                break\n            case '5':\n                grid = setActual(grid, id++, 5)\n                break\n            case '6':\n                grid = setActual(grid, id++, 6)\n                break\n            case '7':\n                grid = setActual(grid, id++, 7)\n                break\n            case '8':\n                grid = setActual(grid, id++, 8)\n                break\n            case '9':\n                grid = setActual(grid, id++, 9)\n                break\n            default:\n                break\n        }\n    }\n\n    return grid\n}\n","import React, { useState, useEffect, useCallback } from 'react'\nimport { AnyAction } from '../actions'\nimport { makeStandardGrid } from '../model/factory'\nimport { importStandardGrid } from '../model/importers'\nimport Grid from '../model/Grid'\nimport './Toolbar.scss'\n\ntype ToolbarProps = {\n    grid: Grid\n    canUndo: boolean\n    canRedo: Boolean\n    dispatch: React.Dispatch<AnyAction>\n}\n\nconst Toolbar: React.FC<ToolbarProps> = ({\n    grid: { data, solved, insoluble },\n    canUndo, canRedo, dispatch\n}) => {\n    const [ content, setContent ] = useState('')\n    const [ running, setRunning ] = useState(false)\n\n    const percent = Math.floor(100 * (solved.length / data.length))\n    const canSolve = !insoluble && (percent < 100)\n    const noSolve = running || !canSolve\n\n    const undo = useCallback(() => dispatch({ type: 'Undo' }), [ dispatch ])\n    const redo = useCallback(() => dispatch({ type: 'Redo' }), [ dispatch ])\n    const step = useCallback(() => dispatch({ type: 'Solve' }), [ dispatch ])\n\n    const clear = useCallback(() => dispatch({\n        type: 'SetGrid',\n        grid: makeStandardGrid()\n    }), [ dispatch ])\n\n    const doImport = useCallback(() => dispatch({\n        type: 'SetGrid',\n        grid: importStandardGrid(content)\n    }), [ content, dispatch ])\n\n    useEffect(() => {\n        if (running) {\n            if (canSolve) {\n                const interval = window.setInterval(step, 250)\n\n                return () => { window.clearInterval(interval) }\n            } else {\n                setRunning(false)\n            }\n        }\n    }, [ canSolve, running, setRunning, step ])\n\n    return (\n        <div className=\"Toolbar\">\n            <span className=\"Solved\">{percent}% Solved</span>\n            {insoluble && <span className=\"Insoluble\">Insoluble</span>}\n            <button onClick={undo} disabled={!canUndo}>Undo</button>\n            <button onClick={redo} disabled={!canRedo}>Redo</button>\n            <button onClick={step} disabled={noSolve}>Step</button>\n            <button onClick={() => setRunning(true)} disabled={noSolve}>Run</button>\n            <button onClick={() => setRunning(false)} disabled={!running}>Stop</button>\n            <button onClick={clear} disabled={running}>Clear</button>\n            <input value={content} onChange={ e => setContent(e.target.value)}/>\n            <button onClick={doImport} disabled={running}>Import</button>\n        </div>\n    )\n}\n\nexport default Toolbar\n","import React from 'react'\nimport Group from '../model/Group'\nimport NumberCell from './NumberCell'\nimport { ALL_VALUES } from '../model/Value'\nimport './BoxCell.scss'\n\ntype BoxCellProps = {\n    group: Group\n}\n\nconst BoxCell: React.FC<BoxCellProps> = ({ group: { missing } }) => {\n    return (\n        <td className=\"BoxCell\">\n            {ALL_VALUES.map(value =>\n                <NumberCell key={value} value={value} possible={missing}/>\n            )}\n        </td>\n    )\n}\n\nexport default React.memo(BoxCell)\n","import React from 'react'\nimport { AnyAction } from '../actions'\nimport ColumnCell from './ColumnCell'\nimport Grid from '../model/Grid'\nimport GridCell from './GridCell'\nimport RowCell from './RowCell'\nimport Toolbar from './Toolbar'\nimport './Table.scss'\nimport BoxCell from './BoxCell'\n\nconst INDICES = [ 0, 1, 2, 3, 4, 5, 6, 7, 8 ]\n\nconst CLASSX = [\n    'GridLeft',\n    '',\n    'GroupRight',\n    'GroupLeft',\n    '',\n    'GroupRight',\n    'GroupLeft',\n    '',\n    'GridRight',\n]\n\nconst CLASSY = [\n    'GridTop',\n    '',\n    'GroupBottom',\n    'GroupTop',\n    '',\n    'GroupBottom',\n    'GroupTop',\n    '',\n    'GridBottom',\n]\n\ntype TableProps = {\n    grid: Grid\n    canUndo: boolean\n    canRedo: Boolean\n    dispatch: React.Dispatch<AnyAction>\n}\n\nconst Table: React.FC<TableProps> = (props) => {\n    const { grid, dispatch } = props\n\n    return (\n        <table className=\"Table\">\n            <thead>\n                <tr>\n                    <td colSpan={9}>\n                        <Toolbar {...props}/>\n                    </td>\n                </tr>\n            </thead>\n            <tbody>\n                {INDICES.map(y =>\n                    <tr key={y}>\n                        {INDICES.map(x =>\n                            <GridCell key={x}\n                                className={`${CLASSY[y]} ${CLASSX[x]}`}\n                                datum={grid.data[(y * 9) + x]}\n                                dispatch={dispatch}/>\n                        )}\n                        <RowCell group={grid.groups[y]}/>\n                    </tr>\n                )}\n                <tr>\n                    {INDICES.map(x =>\n                        <ColumnCell key={x} group={grid.groups[x + 9]}/>\n                    )}\n                    <BoxCell group={grid.groups[18]}/>\n                    <BoxCell group={grid.groups[19]}/>\n                    <BoxCell group={grid.groups[20]}/>\n                </tr>\n                <tr>\n                    <BoxCell group={grid.groups[21]}/>\n                    <BoxCell group={grid.groups[22]}/>\n                    <BoxCell group={grid.groups[23]}/>\n                </tr>\n                <tr>\n                    <BoxCell group={grid.groups[24]}/>\n                    <BoxCell group={grid.groups[25]}/>\n                    <BoxCell group={grid.groups[26]}/>\n                </tr>\n            </tbody>\n        </table>\n    )\n}\n\nexport default React.memo(Table)\n","import React, { useReducer } from 'react'\nimport reducer from './reducer'\nimport Table from './ui/Table'\nimport { makeStandardGrid } from './model/factory'\nimport './App.scss'\n\nfunction App() {\n    const [ { grid, past, future, reset }, dispatch ] = useReducer(\n        reducer, undefined, () => {\n            return { grid: makeStandardGrid(), past: [], future: [] }\n        }\n    )\n\n    return (\n        <div className=\"App\">\n            <Table grid={grid} canUndo={(past.length > 0) || !!reset}\n                canRedo={future.length > 0} dispatch={dispatch}/>\n        </div>\n    );\n}\n\nexport default App\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      process.env.PUBLIC_URL,\n      window.location.href\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}